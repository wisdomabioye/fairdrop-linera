#![cfg_attr(target_arch = "wasm32", no_main)]

mod state;

use self::state::{AuctionData, AuctionState};
use auction::{AuctionAbi, AuctionOperation, AuctionParameters, AuctionResponse};
use fungible::{FungibleOperation, FungibleResponse, FungibleTokenAbi};
use linera_sdk::linera_base_types::{Account, AccountOwner, Amount, ApplicationId, ChainId, StreamUpdate, WithContractAbi};
use linera_sdk::views::{RootView, View};
use linera_sdk::{Contract, ContractRuntime};
use shared::events::{AuctionEvent, ClearReason, AUCTION_STREAM};
use shared::messages::AuctionMessage;
use shared::types::{AuctionParams, BidRecord, SettlementResult};

pub struct AuctionContract {
    state: AuctionState,
    runtime: ContractRuntime<Self>,
}

linera_sdk::contract!(AuctionContract);

impl WithContractAbi for AuctionContract {
    type Abi = AuctionAbi;
}

impl Contract for AuctionContract {
    type Message = AuctionMessage;
    type Parameters = AuctionParameters;
    type InstantiationArgument = ();
    type EventValue = AuctionEvent;

    async fn load(runtime: ContractRuntime<Self>) -> Self {
        let state = AuctionState::load(runtime.root_view_storage_context())
            .await
            .expect("Failed to load state");
        AuctionContract { state, runtime }
    }

    async fn instantiate(&mut self, _argument: Self::InstantiationArgument) {
        // Validate that the application parameters were configured correctly
        let app_params = self.runtime.application_parameters();

        // Emit initialization event to create the stream
        // This ensures the stream exists on every chain where the app is deployed
        let event = AuctionEvent::ApplicationInitialized {
            aac_chain: app_params.aac_chain,
        };
        self.runtime.emit(AUCTION_STREAM.into(), &event);
    }

    async fn execute_operation(&mut self, operation: Self::Operation) -> Self::Response {
        match operation {
            // ═══════════════════════════════════════════════════════════
            // AAC CHAIN OPERATIONS (when called on AAC)
            // UIC OPERATIONS (when called on UIC)
            // ═══════════════════════════════════════════════════════════

            AuctionOperation::CreateAuction { mut params } => {
                let app_params = self.runtime.application_parameters();
                let current_chain = self.runtime.chain_id();

                if current_chain == app_params.aac_chain {
                    // Called on AAC - direct auction creation
                    self.handle_create_auction(params.into()).await
                } else {
                    // Called on UIC - send message to AAC
                    // Override creator with authenticated signer
                    let creator = self.runtime.authenticated_signer()
                        .expect("CreateAuction must be called by authenticated user");
                    params.creator = creator;

                    // Send message to AAC (AAC will generate auction_id)
                    self.runtime
                        .prepare_message(AuctionMessage::CreateAuction { params: params.into() })
                        .send_to(app_params.aac_chain);

                    // Note: auction_id will be generated by AAC and available via indexer query
                    AuctionResponse::Ok
                }
            }

            AuctionOperation::CancelAuction { auction_id } => {
                self.handle_cancel_auction(auction_id).await
            }

            AuctionOperation::PruneSettledAuction { auction_id } => {
                self.handle_prune_settled_auction(auction_id).await
            }

            AuctionOperation::Trigger {} => {
                AuctionResponse::Ok
            }

            // ═══════════════════════════════════════════════════════════
            // UIC CHAIN OPERATIONS
            // ═══════════════════════════════════════════════════════════

            AuctionOperation::Buy { auction_id, quantity } => {
                // Store local commitment (UIC state)
                let mut commitment = self
                    .state
                    .my_commitments
                    .get(&auction_id)
                    .await
                    .unwrap()
                    .unwrap_or_default();

                commitment.total_quantity += quantity;
                self.state
                    .my_commitments
                    .insert(&auction_id, commitment)
                    .unwrap();

                // Send message to AAC chain
                let params = self.runtime.application_parameters();
                let user_chain = self.runtime.chain_id();
                self.runtime
                    .prepare_message(AuctionMessage::PlaceBid {
                        auction_id,
                        user_chain,
                        quantity,
                    })
                    .send_to(params.aac_chain);

                AuctionResponse::BidSubmitted {
                    auction_id,
                    quantity,
                }
            }

            AuctionOperation::SubscribeToAuction { aac_chain } => {
                let app_id = self.runtime.application_id().forget_abi();
                self.runtime.subscribe_to_events(
                    aac_chain,
                    app_id,
                    AUCTION_STREAM.into(),
                );

                AuctionResponse::Ok
            }

            AuctionOperation::UnsubscribeFromAuction { aac_chain } => {
                let app_id = self.runtime.application_id().forget_abi();
                self.runtime.unsubscribe_from_events(
                    aac_chain,
                    app_id,
                    AUCTION_STREAM.into(),
                );

                AuctionResponse::Ok
            }

            AuctionOperation::ClaimSettlement { auction_id } => {
                let app_params = self.runtime.application_parameters();
                let current_chain = self.runtime.chain_id();

                if current_chain == app_params.aac_chain {
                    // Called on AAC - handle directly
                    // AAC_chain should not bid on auctions
                    // self.handle_claim_settlement(auction_id, current_chain).await;
                    AuctionResponse::Ok
                } else {
                    // Called on UIC - send message to AAC
                    self.runtime
                        .prepare_message(AuctionMessage::ClaimSettlement {
                            auction_id,
                            user_chain: current_chain,
                        })
                        .send_to(app_params.aac_chain);

                    AuctionResponse::Ok
                }
            }
        }
    }

    async fn execute_message(&mut self, message: Self::Message) {
        match message {
            // ═══════════════════════════════════════════════════════════
            // MESSAGES RECEIVED BY AAC CHAIN
            // ═══════════════════════════════════════════════════════════

            AuctionMessage::CreateAuction { params } => {
                // Received on AAC from UIC - create the auction
                self.handle_create_auction(params.into()).await;
            }

            AuctionMessage::ClaimSettlement {
                auction_id,
                user_chain,
            } => {
                self.handle_claim_settlement(auction_id, user_chain).await;
            }

            AuctionMessage::PlaceBid {
                auction_id,
                user_chain,
                quantity,
            } => {
                // Delegate to helper function for cleaner code organization
                self.handle_place_bid(auction_id, user_chain, quantity).await;
            }

            // ═══════════════════════════════════════════════════════════
            // MESSAGES RECEIVED BY UIC CHAINS
            // ═══════════════════════════════════════════════════════════

            AuctionMessage::SettlementResult { auction_id, result } => {
                // Received on UIC chain from AAC chain
                let mut commitment = self
                    .state
                    .my_commitments
                    .get(&auction_id)
                    .await
                    .unwrap()
                    .unwrap_or_default();

                commitment.settlement = Some(result);
                self.state
                    .my_commitments
                    .insert(&auction_id, commitment)
                    .unwrap();
            }
        }
    }

    async fn process_streams(&mut self, updates: Vec<StreamUpdate>) {
        for update in updates {
            assert_eq!(update.stream_id.stream_name, AUCTION_STREAM.into());
            assert_eq!(
                update.stream_id.application_id,
                self.runtime.application_id().forget_abi().into()
            );

            for index in update.new_indices() {
                let _event: AuctionEvent =
                    self.runtime
                        .read_event(update.chain_id, AUCTION_STREAM.into(), index);

                // UIC can process events for live updates if needed
                // For now, we just acknowledge receiving them
            }
        }
    }

    async fn store(mut self) {
        self.state.save().await.expect("Failed to save state");
    }
}

impl AuctionContract {
    // ═══════════════════════════════════════════════════════════
    // Operation Handlers
    // ═══════════════════════════════════════════════════════════

    /// Handle auction creation on AAC chain
    async fn handle_create_auction(&mut self, params: AuctionParams) -> AuctionResponse {
        // Validate on AAC chain
        assert_eq!(
            self.runtime.chain_id(),
            self.runtime.application_parameters().aac_chain,
            "Only AAC chain can create auctions"
        );

        // Auto-generate auction ID
        let auction_id = *self.state.next_auction_id.get();
        self.state.next_auction_id.set(auction_id + 1);

        let auction = AuctionData::new(params.clone(), self.runtime.system_time());

        self.state.auctions.insert(&auction_id, auction).unwrap();

        // Emit creation event with full params
        let event = AuctionEvent::AuctionCreated {
            auction_id,
            item_name: params.item_name.clone(),
            total_supply: params.total_supply,
            start_price: params.start_price,
            floor_price: params.floor_price,
            price_decay_interval: params.price_decay_interval,
            price_decay_amount: params.price_decay_amount,
            start_time: params.start_time,
            end_time: params.end_time,
            creator: params.creator,
            payment_token_app: params.payment_token_app,
        };
        self.runtime.emit(AUCTION_STREAM.into(), &event);

        AuctionResponse::AuctionCreated { auction_id }
    }

    /// Handle auction cancellation by creator (before start, AAC only)
    async fn handle_cancel_auction(&mut self, auction_id: u64) -> AuctionResponse {
        // Validate on AAC chain
        assert_eq!(
            self.runtime.chain_id(),
            self.runtime.application_parameters().aac_chain,
            "Only AAC chain can cancel auctions"
        );

        let auction = self
            .state
            .auctions
            .get(&auction_id)
            .await
            .expect("Failed to get auction")
            .expect("Auction not found");

        // Validate caller is the creator
        let authenticated_signer = self.runtime.authenticated_signer()
            .expect("Caller must be authenticated to cancel auction");

        assert_eq!(
            authenticated_signer,
            auction.params.creator,
            "Only the creator can cancel the auction"
        );

        // Validate auction is in Scheduled status
        assert_eq!(
            auction.status,
            shared::types::AuctionStatus::Scheduled,
            "Only scheduled auctions can be cancelled (auction must not have started yet)"
        );

        // Update auction status to Cancelled
        let auction_mut = self.state.auctions.get_mut(&auction_id).await.unwrap().unwrap();
        auction_mut.status = shared::types::AuctionStatus::Cancelled;

        // Emit cancellation event
        let reason = format!(
            "Cancelled by creator before start_time ({:?})",
            auction.params.start_time
        );

        let event = AuctionEvent::AuctionCancelled {
            auction_id,
            reason,
        };
        self.runtime.emit(AUCTION_STREAM.into(), &event);

        AuctionResponse::Ok
    }

    /// Handle pruning of settled auction bids (two-tier strategy)
    async fn handle_prune_settled_auction(&mut self, auction_id: u64) -> AuctionResponse {
        let auction = self
            .state
            .auctions
            .get(&auction_id)
            .await
            .expect("Failed to get auction")
            .expect("Auction not found");

        // Validate auction is settled
        assert_eq!(
            auction.status,
            shared::types::AuctionStatus::Settled,
            "Auction not settled"
        );

        // Calculate elapsed time since settlement
        let one_hour_micros = 60 * 60 * 1_000_000u64;
        let ninety_days_micros = 90 * 24 * 60 * 60 * 1_000_000u64;
        let settled_at = auction.settled_at.expect("Settled time not set");
        let elapsed = self.runtime.system_time().delta_since(settled_at).as_micros();

        // Must be at least 1 hour after settlement to prune
        assert!(
            elapsed >= one_hour_micros,
            "Auction settled less than 1 hour ago. Cannot prune yet."
        );

        // Two-tier pruning strategy
        let prune_all = elapsed >= ninety_days_micros;

        // Iterate over all user-auction combinations to find bids for this auction
        let all_keys: Vec<(ChainId, u64)> = self.state.user_auction_bids.indices().await.unwrap();

        for (user_chain, auction_id_key) in all_keys {
            if auction_id_key == auction_id {
                let user_bids = self
                    .state
                    .user_auction_bids
                    .get(&(user_chain, auction_id))
                    .await
                    .unwrap()
                    .unwrap_or_default();

                if prune_all {
                    // Tier 2 (90+ days): Prune all bids for this user-auction
                    self.state
                        .user_auction_bids
                        .remove(&(user_chain, auction_id))
                        .unwrap();
                } else {
                    // Tier 1 (1hr - 90 days): Prune only claimed bids
                    let mut filtered_bids = user_bids;
                    filtered_bids.retain(|bid| !bid.claimed);

                    if filtered_bids.is_empty() {
                        // Remove entry if all bids were pruned
                        self.state
                            .user_auction_bids
                            .remove(&(user_chain, auction_id))
                            .unwrap();
                    } else {
                        // Update with remaining bids
                        self.state
                            .user_auction_bids
                            .insert(&(user_chain, auction_id), filtered_bids)
                            .unwrap();
                    }
                }
            }
        }

        // Update auction to mark bids as pruned (if all were pruned)
        if prune_all {
            let auction_mut = self.state.auctions.get_mut(&auction_id).await.unwrap().unwrap();
            auction_mut.bids_pruned = true;
        }

        AuctionResponse::Ok
    }

    // ═══════════════════════════════════════════════════════════
    // Message Handlers
    // ═══════════════════════════════════════════════════════════

    /// Handle settlement claim from user chain (AAC processes this)
    async fn handle_claim_settlement(&mut self, auction_id: u64, user_chain: ChainId) {
        // Verify auction is settled
        let auction = self
            .state
            .auctions
            .get(&auction_id)
            .await
            .expect("Failed to get auction")
            .expect("Auction not found");

        assert_eq!(
            auction.status,
            shared::types::AuctionStatus::Settled,
            "Auction not settled yet"
        );

        let clearing_price = auction.clearing_price.expect("Clearing price not set");

        // O(1) lookup: Get all unclaimed bids for this user and auction
        let mut user_bids = self
            .state
            .user_auction_bids
            .get(&(user_chain, auction_id))
            .await
            .unwrap()
            .unwrap_or_default();

        // Calculate totals from unclaimed bids
        let mut total_quantity = 0u64;
        let mut total_paid = Amount::ZERO;
        let mut has_unclaimed = false;

        for bid in &user_bids {
            if !bid.claimed {
                total_quantity += bid.quantity;
                total_paid = total_paid.saturating_add(bid.amount_paid);
                has_unclaimed = true;
            }
        }

        // Check if user has any unclaimed bids
        if !has_unclaimed {
            // No unclaimed bids - either never bid or already claimed
            return;
        }

        // Calculate settlement
        let total_cost = clearing_price.saturating_mul(total_quantity as u128);
        let refund = total_paid.saturating_sub(total_cost);

        // Get authenticated bidder (for refund recipient)
        let bidder = self
            .runtime
            .authenticated_signer()
            .expect("ClaimSettlement must be authenticated");

        // Get payment token app for refund transfer
        let payment_token_app = auction.params.payment_token_app;

        // Drop auction reference before function call
        drop(auction);

        // Mark all bids as claimed
        for bid in &mut user_bids {
            if !bid.claimed {
                bid.claimed = true;
            }
        }

        // Save updated bids
        self.state
            .user_auction_bids
            .insert(&(user_chain, auction_id), user_bids)
            .unwrap();

        // Execute refund transfer (synchronous - on AAC)
        self.refund_payment(auction_id, bidder, refund, payment_token_app);

        // Send settlement result to user
        self.runtime
            .prepare_message(AuctionMessage::SettlementResult {
                auction_id,
                result: SettlementResult {
                    allocated_quantity: total_quantity,
                    clearing_price,
                    total_cost,
                    refund,
                },
            })
            .send_to(user_chain);

        // Emit settlement claimed event
        let event = AuctionEvent::SettlementClaimed {
            auction_id,
            user_chain,
            allocated_quantity: total_quantity,
            clearing_price,
            total_cost,
            refund,
        };
        self.runtime.emit(AUCTION_STREAM.into(), &event);
    }

    // ═══════════════════════════════════════════════════════════
    // Utility Functions
    // ═══════════════════════════════════════════════════════════

    /// Calculate current price based on elapsed time since auction start
    /// On-demand calculation - no need to store or update price
    async fn calculate_current_price(&mut self, auction_id: u64) -> Amount {
        let auction = self
            .state
            .auctions
            .get(&auction_id)
            .await
            .expect("Failed to get auction")
            .expect("Auction not found");

        let current_time = self.runtime.system_time();

        // Use shared utility function
        shared::calculate_current_price(
            auction.params.start_price,
            auction.params.floor_price,
            auction.params.price_decay_amount,
            auction.params.price_decay_interval,
            auction.params.start_time,
            current_time,
        )
    }

    /// Handle bid placement from user chains
    /// This helper function encapsulates all bid processing logic
    async fn handle_place_bid(&mut self, auction_id: u64, user_chain: ChainId, quantity: u64) {
        // Calculate current price on-demand
        let current_price = self.calculate_current_price(auction_id).await;
        let now = self.runtime.system_time();

        // Get mutable reference to auction for bid processing
        let auction = self.state.auctions.get_mut(&auction_id).await.unwrap().unwrap();

        // Handle Scheduled → Active transition
        if auction.status == shared::types::AuctionStatus::Scheduled {
            if now >= auction.params.start_time {
                // Auction has started, transition to Active
                auction.status = shared::types::AuctionStatus::Active;
            } else {
                // Auction not started yet, reject bid
                let event = AuctionEvent::BidRejected {
                    auction_id,
                    user_chain,
                    reason: format!(
                        "Auction not started yet. Starts at: {:?}",
                        auction.params.start_time
                    ),
                };
                self.runtime.emit(AUCTION_STREAM.into(), &event);
                return;
            }
        }

        // Check if auction has expired (time-based expiration)
        if now > auction.params.end_time && auction.status == shared::types::AuctionStatus::Active {
            // Auction expired - trigger settlement
            auction.clearing_price = Some(current_price);
            auction.status = shared::types::AuctionStatus::Ended;
            let total_bids = auction.total_bids;

            let event = AuctionEvent::AuctionCleared {
                auction_id,
                clearing_price: current_price,
                total_bids,
                reason: ClearReason::TimeExpired,
            };
            self.runtime.emit(AUCTION_STREAM.into(), &event);

            // Drop auction reference before calling settle_auction
            let _ = auction;

            // Auto-settle expired auction
            self.settle_auction(auction_id).await;

            // Reject this bid (auction already expired)
            let event = AuctionEvent::BidRejected {
                auction_id,
                user_chain,
                reason: format!(
                    "Auction expired at: {:?}",
                    self.state.auctions.get(&auction_id).await.unwrap().unwrap().params.end_time
                ),
            };
            self.runtime.emit(AUCTION_STREAM.into(), &event);
            return;
        }

        // Check if auction still active
        if auction.status != shared::types::AuctionStatus::Active {
            let event = AuctionEvent::BidRejected {
                auction_id,
                user_chain,
                reason: "Auction not active".to_string(),
            };
            self.runtime.emit(AUCTION_STREAM.into(), &event);
            return;
        }

        // Calculate available quantity
        let remaining = auction.total_supply.saturating_sub(auction.sold);
        if remaining == 0 {
            let event = AuctionEvent::BidRejected {
                auction_id,
                user_chain,
                reason: "Supply exhausted".to_string(),
            };
            self.runtime.emit(AUCTION_STREAM.into(), &event);
            return;
        }

        let accepted_quantity = quantity.min(remaining);

        // Calculate amount to pay
        let amount_paid = current_price.saturating_mul(accepted_quantity as u128);

        // Get authenticated bidder (works cross-chain)
        let bidder = self
            .runtime
            .authenticated_signer()
            .expect("PlaceBid must be authenticated");

        // Get payment token app for this auction
        // Note: payment_token_app is stored as ApplicationId (untyped) for serialization
        // We'll convert it when calling the fungible application
        let payment_token_app = auction.params.payment_token_app;

        // Drop auction reference before function call
        let _ = auction;

        // Collect payment from user (synchronous - on AAC)
        // If user has insufficient balance on AAC, this will fail
        if let Err(reason) = self.collect_payment(bidder, amount_paid, payment_token_app) {
            // Payment failed - reject bid
            let event = AuctionEvent::BidRejected {
                auction_id,
                user_chain,
                reason: format!("Payment failed: {}. Ensure you have sufficient fungible token balance on AAC", reason),
            };
            self.runtime.emit(AUCTION_STREAM.into(), &event);
            return;
        }

        // Create bid record
        let bid_id = *self.state.next_bid_id.get();
        self.state.next_bid_id.set(bid_id + 1);

        let bid = BidRecord {
            bid_id,
            auction_id,
            user_chain,
            quantity: accepted_quantity,
            amount_paid,
            timestamp: self.runtime.system_time(),
            claimed: false,
        };

        // Insert bid using composite key for O(1) lookups
        let mut user_bids = self
            .state
            .user_auction_bids
            .get(&(user_chain, auction_id))
            .await
            .unwrap()
            .unwrap_or_default();

        let is_first_bid_from_user = user_bids.is_empty();
        user_bids.push(bid);
        self.state
            .user_auction_bids
            .insert(&(user_chain, auction_id), user_bids)
            .unwrap();

        // Re-acquire auction reference to update counters
        let auction = self.state.auctions.get_mut(&auction_id).await.unwrap().unwrap();

        // Update sold quantity and cached counters
        auction.sold += accepted_quantity;
        auction.total_bids += 1;
        if is_first_bid_from_user {
            auction.total_bidders += 1;
        }

        // Update user total
        let user_total = self
            .state
            .user_totals
            .get(&(auction_id, user_chain))
            .await
            .unwrap()
            .unwrap_or(0);
        self.state
            .user_totals
            .insert(&(auction_id, user_chain), user_total + accepted_quantity)
            .unwrap();

        // Emit payment received event
        let payment_event = AuctionEvent::PaymentReceived {
            auction_id,
            user_chain,
            amount: amount_paid,
            bid_id,
        };
        self.runtime.emit(AUCTION_STREAM.into(), &payment_event);

        // Emit bid accepted event
        let event = AuctionEvent::BidAccepted {
            auction_id,
            bid_id,
            user_chain,
            quantity: accepted_quantity,
            amount_paid,
            total_sold: auction.sold,
            remaining: auction.total_supply - auction.sold,
        };
        self.runtime.emit(AUCTION_STREAM.into(), &event);

        // Check if supply exhausted
        let supply_exhausted = auction.sold >= auction.total_supply;
        if supply_exhausted {
            auction.clearing_price = Some(current_price);
            auction.status = shared::types::AuctionStatus::Ended;
            let total_bids = auction.total_bids;

            let event = AuctionEvent::AuctionCleared {
                auction_id,
                clearing_price: current_price,
                total_bids,
                reason: ClearReason::SupplyExhausted,
            };
            self.runtime.emit(AUCTION_STREAM.into(), &event);

            // Drop auction reference before calling settle_auction
            let _ = auction;

            // Auto-settle
            self.settle_auction(auction_id).await;
        }
    }

    /// Settle auction (manual claim-based settlement - no auto-messaging)
    async fn settle_auction(&mut self, auction_id: u64) {
        // Get mutable reference for updating status
        let auction = self
            .state
            .auctions
            .get_mut(&auction_id)
            .await
            .unwrap()
            .expect("Auction not found");

        let clearing_price = auction.clearing_price.expect("Clearing price not set");
        let total_bidders = auction.total_bidders;
        let total_sold = auction.sold;

        // Update auction status to Settled
        auction.status = shared::types::AuctionStatus::Settled;
        auction.settled_at = Some(self.runtime.system_time());

        // Emit settlement event
        // NOTE: Users must manually claim their settlements via ClaimSettlement operation
        let event = AuctionEvent::AuctionSettled {
            auction_id,
            clearing_price,
            total_bidders,
            total_sold,
        };
        self.runtime.emit(AUCTION_STREAM.into(), &event);
    }

    /// Helper: Collect payment from user to escrow (synchronous on AAC)
    /// Returns Ok if successful, Err with reason if payment fails
    fn collect_payment(
        &mut self,
        bidder: AccountOwner,
        amount: Amount,
        payment_token_app: ApplicationId,
    ) -> Result<(), String> {
        // Define escrow account owned by the application
        let escrow_account = Account {
            chain_id: self.runtime.chain_id(), // AAC chain
            owner: self.runtime.application_id().into(), // App-owned escrow
        };

        // Transfer from bidder (on AAC) to escrow (on AAC) - synchronous
        let transfer_operation = FungibleOperation::Transfer {
            owner: bidder,
            amount,
            target_account: escrow_account,
        };

        // Convert untyped ApplicationId to typed for the call
        let typed_app: ApplicationId<FungibleTokenAbi> = unsafe {
            std::mem::transmute(payment_token_app)
        };

        // Call fungible token application (synchronous - same chain)
        // This will fail immediately if user has insufficient balance
        match self.runtime.call_application(true, typed_app, &transfer_operation) {
            FungibleResponse::Ok => Ok(()),
            FungibleResponse::Balance(_) | FungibleResponse::TickerSymbol(_) | FungibleResponse::TokenName(_) => {
                Err("Unexpected response from fungible token".to_string())
            }
        }
    }

    /// Helper: Refund excess payment to user after settlement (synchronous on AAC)
    fn refund_payment(
        &mut self,
        auction_id: u64,
        bidder: AccountOwner,
        refund_amount: Amount,
        payment_token_app: ApplicationId,
    ) {
        if refund_amount == Amount::ZERO {
            return; // No refund needed
        }

        // User account on AAC (refund stays on AAC for fast settlement)
        let user_account = Account {
            chain_id: self.runtime.chain_id(), // AAC
            owner: bidder,
        };

        // Transfer from escrow (app-owned) back to user
        let transfer_operation = FungibleOperation::Transfer {
            owner: self.runtime.application_id().into(), // From app escrow
            amount: refund_amount,
            target_account: user_account,
        };

        // Convert untyped ApplicationId to typed for the call
        let typed_app: ApplicationId<FungibleTokenAbi> = unsafe {
            std::mem::transmute(payment_token_app)
        };

        // Call fungible token application (synchronous - same chain)
        match self.runtime.call_application(true, typed_app, &transfer_operation) {
            FungibleResponse::Ok => {
                // Emit refund event
                let event = AuctionEvent::RefundIssued {
                    auction_id,
                    user_chain: self.runtime.chain_id(), // AAC
                    refund_amount,
                };
                self.runtime.emit(AUCTION_STREAM.into(), &event);
            }
            _ => {
                // This should not fail since escrow has the funds
                panic!("Failed to refund payment to user");
            }
        }
    }

}
